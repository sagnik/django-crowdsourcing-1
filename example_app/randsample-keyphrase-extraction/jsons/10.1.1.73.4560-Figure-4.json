{"Caption":"Figure 4: Unrolled and Merged Control Flow Graph. C(i, j) denotes the logical condition such that the loop iteration with wrap = i will continue to the loop iteration with wrap = j. For clarity, we haven\u2019t drawn the graph edges and vertices inside the loop bodies; the actual CFG, of course, does have those details. ","ImageText":[{"Text":"C(0,","TextBB":[293.902,76.2875,310.304,84.723],"Rotation":0},{"Text":"k)","TextBB":[312.647,76.2875,320.455,84.723],"Rotation":0},{"Text":"C(2,k+2","TextBB":[381.068,84.7234,412.13,93.1588],"Rotation":0},{"Text":")","TextBB":[414.473,84.7234,417.594,93.1588],"Rotation":0},{"Text":"...","TextBB":[291.089,95.1913,305.148,112.062],"Rotation":0},{"Text":"C(0,","TextBB":[229.23,107.217,245.632,115.652],"Rotation":0},{"Text":"2)","TextBB":[247.976,107.217,255.783,115.652],"Rotation":0},{"Text":"..","TextBB":[367.009,109.251,371.695,131.745],"Rotation":0},{"Text":".","TextBB":[367.009,120.498,371.695,137.369],"Rotation":0},{"Text":"C(2,3","TextBB":[338.892,132.523,359.98,140.959],"Rotation":0},{"Text":")","TextBB":[362.324,132.523,365.445,140.959],"Rotation":0},{"Text":"C(0,","TextBB":[172.993,121.276,189.395,129.711],"Rotation":0},{"Text":"1)","TextBB":[191.739,121.276,199.546,129.711],"Rotation":0},{"Text":"wrap","TextBB":[91.4504,157.829,110.186,166.265],"Rotation":0},{"Text":"=","TextBB":[112.53,157.829,117.816,166.265],"Rotation":0},{"Text":"0","TextBB":[120.159,157.829,124.845,166.265],"Rotation":0},{"Text":"loop","TextBB":[91.4504,171.888,108.115,180.323],"Rotation":0},{"Text":"body","TextBB":[110.458,171.888,129.204,180.323],"Rotation":0},{"Text":"wrap","TextBB":[198.299,157.829,217.035,166.265],"Rotation":0},{"Text":"=","TextBB":[219.379,157.829,224.665,166.265],"Rotation":0},{"Text":"1","TextBB":[227.008,157.829,231.694,166.265],"Rotation":0},{"Text":"loop","TextBB":[198.299,169.077,214.964,177.512],"Rotation":0},{"Text":"body","TextBB":[217.307,169.077,236.053,177.512],"Rotation":0},{"Text":"wrap","TextBB":[305.148,157.829,323.884,166.265],"Rotation":0},{"Text":"=","TextBB":[326.227,157.829,331.513,166.265],"Rotation":0},{"Text":"2","TextBB":[333.857,157.829,338.543,166.265],"Rotation":0},{"Text":"loop","TextBB":[305.148,169.077,321.813,177.512],"Rotation":0},{"Text":"body","TextBB":[324.156,169.077,342.901,177.512],"Rotation":0},{"Text":"C(1,","TextBB":[262.971,191.571,279.373,200.007],"Rotation":0},{"Text":"2)","TextBB":[281.716,191.571,289.524,200.007],"Rotation":0},{"Text":"..","TextBB":[316.395,199.228,321.081,221.723],"Rotation":0},{"Text":".","TextBB":[316.397,193.606,321.084,210.476],"Rotation":0},{"Text":"C(k,","TextBB":[516.034,129.712,532.436,138.147],"Rotation":0},{"Text":"k+1)","TextBB":[534.779,129.712,552.559,138.147],"Rotation":0},{"Text":"...","TextBB":[392.315,147.449,416.918,176.973],"Rotation":0},{"Text":".","TextBB":[347.326,171.111,352.013,187.982],"Rotation":0},{"Text":"..","TextBB":[636.942,92.38,641.628,114.874],"Rotation":0},{"Text":".","TextBB":[636.942,103.627,641.628,120.498],"Rotation":0},{"Text":"C(k,","TextBB":[561.023,110.028,577.425,118.464],"Rotation":0},{"Text":"2k)","TextBB":[579.769,110.028,592.262,118.464],"Rotation":0},{"Text":"...","TextBB":[600.389,140.181,614.448,157.051],"Rotation":0},{"Text":"wrap","TextBB":[434.491,157.829,453.227,166.265],"Rotation":0},{"Text":"=","TextBB":[455.57,157.829,460.856,166.265],"Rotation":0},{"Text":"k","TextBB":[463.2,157.829,467.886,166.265],"Rotation":0},{"Text":"loop","TextBB":[434.491,169.077,451.156,177.512],"Rotation":0},{"Text":"body","TextBB":[453.499,169.077,472.244,177.512],"Rotation":0},{"Text":"wrap","TextBB":[538.53,157.83,557.266,166.265],"Rotation":0},{"Text":"=","TextBB":[559.609,157.83,564.895,166.265],"Rotation":0},{"Text":"k","TextBB":[567.238,157.83,571.925,166.265],"Rotation":0},{"Text":"+","TextBB":[574.268,157.83,579.554,166.265],"Rotation":0},{"Text":"1","TextBB":[581.897,157.83,586.583,166.265],"Rotation":0},{"Text":"loop","TextBB":[538.528,169.077,555.193,177.512],"Rotation":0},{"Text":"body","TextBB":[557.536,169.077,576.281,177.512],"Rotation":0},{"Text":"...","TextBB":[636.942,144.638,661.545,174.162],"Rotation":0},{"Text":".","TextBB":[620.072,171.11,624.758,187.981],"Rotation":0},{"Text":".","TextBB":[620.072,176.734,624.758,193.605],"Rotation":0},{"Text":"wrap","TextBB":[715.673,155.017,734.409,163.453],"Rotation":0},{"Text":">=","TextBB":[736.752,155.017,747.324,163.453],"Rotation":0},{"Text":"n","TextBB":[749.667,155.017,754.354,163.453],"Rotation":0},{"Text":"exit","TextBB":[715.673,166.265,729.732,174.7],"Rotation":0},{"Text":"loop","TextBB":[732.075,166.265,748.74,174.7],"Rotation":0},{"Text":".","TextBB":[631.318,204.852,636.005,221.723],"Rotation":0},{"Text":".","TextBB":[631.318,210.476,636.005,227.347],"Rotation":0},{"Text":".","TextBB":[631.318,216.1,636.005,232.971],"Rotation":0},{"Text":"C(1,","TextBB":[355.76,211.254,372.162,219.689],"Rotation":0},{"Text":"k)","TextBB":[374.506,211.254,382.313,219.689],"Rotation":0},{"Text":"C(1,","TextBB":[395.128,233.749,411.53,242.184],"Rotation":0},{"Text":"k+1)","TextBB":[413.873,233.749,431.653,242.184],"Rotation":0}],"Mention":["Because we are treating the software as \u201Ccombinational,\u201D we\nperform a preliminary pass to unroll loops and obtain an acyclic\nCFG. Simple loops, e.g., with constant bounds and increments, can\nbe unrolled in the obvious manner (cf. [15]). For more complex\nloops, such as the main instruction length decoder loop (Figure 3),\nmore sophisticated techniques are needed, as in advanced com-\npiler\/synthesis optimization (cf. [8]). In our method, the dataflow\nanalysis tells us that wrap is the only loop-carried dependence.\nTherefore, we know that wrap is the only information that must\nbe tracked in distinguishing different iterations of the loop body.\nAccordingly, as we unroll the loop, any two paths that (re)enter the\nloop with the same value of wrap can be merged. The net result is\nthat the tool automatically unrolls the original CFG into the graph\nshown in Figure 4.\nThere are two key points about this preliminary phase. First is\nthat the construction, and the resulting graph, are linear in the size\nof the software (with loops unrolled). There is no exponential blow-\n","ing condition C(i,k) that control flowed from i to k was also true.\nBecause the unrolled CFG is acyclic, this computation examines\neach edge exactly once, yielding the linear complexity. This lin-\near construction is a state-of-the-art symbolic simulation approach\nto converting the software model into BDDs or some other func-\ntion representation. We are now ready to consider early cutpoint\ninsertion.\nThe key idea of early cutpoint insertion is to look for cutpoints\nduring the above computation of N(k) rather than after it is com-\npleted. If we find some N(i) (or any other BDD during symbolic\nsimulation) that is equal to some point in the gate-level circuit, we\ncan cut out the equivalent logic in the software and the hardware,\nand introduce a new primary input in its place. This eliminates the\ncomplexity of the logic for N(i) in subsequent computations. As\nwith gate-level cutpoints, if we can continue this process to the out-\nputs of the software and hardware models, then we have formally\nverified equivalence.\nFor example, Figure 5 shows some cutpoints added to Figure 4.\nIf we prove that the node condition for loop body 0 is the same as\nsome logic in the gate-level circuit, we can cut out the logic and\n","We now proceed to the main phase of the verification algorithm.\nTo formally verify equivalence between the software and hardware\nmodels, the algorithm must derive some representation of the func-\ntion computed at the output of each model. For both gate-level\nhardware or an execution path in software, symbolic simulation\nis the standard method to derive these representations. We use\nBDDs [4] to represent the functions in symbolic simulation: they\nare reasonably efficient, and canonicity makes proving equivalence\nand finding cutpoints easy.\nAs mentioned above, the value of a variable at a given point in the\nprogram depends on the path taken through the program to reach\nthat point. A direct approach is to enumerate all paths through the\nsoftware and verify equivalence for each path individually. Unfor-\ntunately, the number of paths can be exponential.\nAlternatively, to avoid enumerating all the paths, we can merge\npaths during symbolic simulation, using conditional expressions to\ntrack the different values possible along different paths. Path merg-\ning, therefore, requires computing what input conditions will cause\na given point in the program to execute (and affect the variables).\nFor example, in Figure 4, the software code in loop body k will\naffect the values of the variables iff the execution starting from the\ninitial value of wrap followed a path that eventually reached loop\n","tions for control flow within the loop bodies, not drawn in Figure 4,\n"],"Page":4,"Number":4,"Type":"Figure","CaptionBB":[73,264,772,307],"Height":1100,"Width":850,"DPI":100,"ImageBB":[77,73,770,249]}