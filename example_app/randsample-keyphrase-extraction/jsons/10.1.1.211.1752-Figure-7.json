{"Caption":"Figure 7: An idempotent processor with a slice data buffer (SDB).","ImageText":[],"Mention":["Enhancing performance. Power and complexity savings\nare enabled by the opportunity to eliminate staging, by-\npassing, and support for replay traps in an idempotent pro-\ncessor. To demonstrate how idempotent processing enables\nout-of-order issue at low complexity cost, we propose con-\nverting some of these savings into improved performance by\nadding a small, 4-entry slice data buffer (SDB), as proposed\nin previous work [25, 35], to hold miss-dependent instruc-\ntions and their operands. Instructions that are dependent\non a load miss are issued to the SDB for re-issue at a later\nstage, unblocking the pipeline. Subsequent instructions may\nthen issue out of order with respect to instructions in the\nSDB. In an idempotent processor, these instructions may\nalso retire out of order; hence, the functionality of the SDB\nis synergistic with the relaxation of in-order retirement in\nan idempotent processor. To further exploit the SDB, we\nadd a non-blocking cache with 2 MSHRs. We also allow\nthe processor to use the SDB when no misses are outstand-\ning, in which case instructions blocked on a single operand\nmay issue to the SDB, unblocking the pipeline. This allows\nthe processor to execute ahead of long latency multiplies\nand floating point operations. Note that, to allow recovery\nfrom branch mispredictions as before (i.e. by flushing the\npipeline), dependent branch instructions do not issue to the\nSDB. Details of our particular SDB design follow.\nFigure 7 shows the SDB integrated into our idempotent\nprocessor. It is implemented as a circular buffer and hence\ndrains in order. Two instructions may issue to and from\nthe SDB per cycle. Similarly to the replay queue described\nin Section 4, the SDB issues miss-dependent instructions to\ncoincide with the time that the cache miss is serviced. De-\npendence information is tracked using a special write vector\n(one bit per register), which tracks which registers are writ-\nten by instructions in the SDB. The write vector is updated\nwhen an instruction issues to the SDB, and it is cleared only\nonce the SDB is empty. Between idempotent regions, if the\nSDB is non-empty, issue blocks and the SDB drains to en-\n","Staging, full bypass, replay logic (Figure 6(b))\nOut-of-order retirement (Figure 6(a))\nOut-of-order retirement, 4-entry SDB, non-blocking cache (Figure 7)\n24-entry ROB, 16-entry IQ, 16-entry LSQ, 24 INT & 24 FP extra regs\n"],"Page":8,"Number":7,"Type":"Figure","CaptionBB":[203,293,636,306],"Height":1100,"Width":850,"DPI":100,"ImageBB":[160,73,681,275]}