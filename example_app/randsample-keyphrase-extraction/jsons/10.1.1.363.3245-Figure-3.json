{"Caption":"Figure 3: add operation applied to firewall","ImageText":[{"Text":"Source","TextBB":[136.667,244.106,168.915,254.069],"Rotation":0},{"Text":"Destination","TextBB":[177,244.106,230.821,254.069],"Rotation":0},{"Text":"Proto","TextBB":[240.5,244.106,266.701,254.069],"Rotation":0},{"Text":"Other","TextBB":[274.5,244.106,302.748,254.069],"Rotation":0},{"Text":"Action","TextBB":[310.666,244.106,341.821,254.069],"Rotation":0},{"Text":"*","TextBB":[136.667,257.439,142.201,267.402],"Rotation":0},{"Text":"10.20.1.0\/24","TextBB":[177,257.439,232.535,267.402],"Rotation":0},{"Text":"TCP","TextBB":[240.5,257.439,260.821,267.402],"Rotation":0},{"Text":"*","TextBB":[274.5,257.439,280.034,267.402],"Rotation":0},{"Text":"DROP","TextBB":[310.666,257.439,339.654,267.402],"Rotation":0}],"Mention":["We propose an abstraction that leverages this inherent map-\nping of state to protocol header values to provide a myopic\nview of the complex and detailed state associated with a\nMB. The view abstraction (Figure 1) uses pertinent proto-\ncol header fields as a key for each distinct chunk of action\nand\/or supporting state. Figures 2 and 3 show examples of\nstate encoded using this abstraction.\nThe key is carefully constructed to identify exactly the\ntraffic subsets to which a piece of state applies. A basic 5-\ntuple (source\/destination network addresses, transport pro-\ntocol, and source\/destination transport ports) is a sufficient\nkey for most state, but the protocol fields that form the key\nare flexible. Defining keys in this way enables us to leverage\nthe ubiquity of common protocols to counteract MB diver-\nsity. Moreover, it provides an inherent hierarchy (e.g., IP\naddresses are hierarchical by design) for identifying subsets\nand supersets of state.\nAction state is more challenging to represent because of\nits intrinsic tie to MBs\u2019 internal logic. For example, ac-\ntion state for firewalls is accept\/drop rules, while action state\nfor NATs is a mapping from public addresses\/ports to pri-\nvate addresses\/ports. We could represent action state as a\nbinary blob. However, this would make creation and ma-\nnipulation of action state complex because of the need for\na deep understanding of MB semantics for the target MB.\nInstead, we propose to represent action state as a transfor-\nmation function that changes specific packet header fields to\n","\u2022 add(state, MB) \u2013 Adds a chunk of state, encoded us-\ning our view abstraction, to the MB. Figure 3 shows an\nexample add operation that instantiates a firewall rule\nto drop traffic for a specific subnet.\n"],"Page":5,"Number":3,"Type":"Figure","CaptionBB":[121,273,358,287],"Height":1100,"Width":850,"DPI":100,"ImageBB":[130,201,348,268]}