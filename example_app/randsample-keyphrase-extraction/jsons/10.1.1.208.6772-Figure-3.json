{"Caption":"Figure 3: Load a word in memory into %eax.","ImageText":[{"Text":"movl","TextBB":[524.124,146.47,556.447,163.224],"Rotation":0},{"Text":"64(%eax),","TextBB":[561.789,146.47,631.331,163.224],"Rotation":0},{"Text":"%eax","TextBB":[636.648,146.47,672.589,163.224],"Rotation":0},{"Text":"ret","TextBB":[524.124,166.303,542.67,183.057],"Rotation":0},{"Text":"pop","TextBB":[524.124,213.137,549.462,229.89],"Rotation":0},{"Text":"%eax","TextBB":[554.788,213.137,590.729,229.89],"Rotation":0},{"Text":"ret","TextBB":[524.124,232.97,542.67,249.724],"Rotation":0},{"Text":"%esp","TextBB":[212.124,226.137,247.285,242.891],"Rotation":0},{"Text":"0xdeadbeef","TextBB":[326.458,310.849,411.572,326.275],"Rotation":0},{"Text":"+","TextBB":[171.291,326.27,183.944,342.891],"Rotation":0},{"Text":"64","TextBB":[187.798,326.27,204.108,342.891],"Rotation":0}],"Mention":["We choose to load from memory into the register %eax, using the sequence movl 64(%eax), %eax;\nret. We first load the address into %eax, using, for example, the constant-load procedure detailed\nabove. Because of the immediate offset in the movl instruction we use, the address in %eax must\nactually be 64 bytes less than the address we wish to load. We then apply the movl sequence, after\nwhich %eax contains the contents of the memory location. The procedure is detailed in Figure 3.\nNote the notation we use to signify, \u201Cthe pointer in this cell requires that 64 be added to it so that\nit points to some other cell.\u201D\n","computes the sum of its two operands and the carry flag, which is useful in multiword addition\nalgorithms. If we take the two operands to be zero, the result is 1 or 0 depending on whether the\ncarry flag is set\u2014exactly what we need. This we can do quite easily by clearing %ecx and using\nthe instruction sequence adc %cl, %cl; ret. The process is detailed in Figure 12. We note, finally,\nthat we can evaluate complicated Boolean expressions by collecting CF values for multiple tests\nand combining them with the logical operations described in Section 3.2.\nFor the third task, we proceed as follows. We have a word in memory that contains 1 or 0.\nWe transform it to contain either esp delta or 0, where esp delta is the amount we\u2019d like to\nperturb %esp by if the condition evaluates as true. One way to do this is as follows. The two\u2019s\ncomplement of 1 is the all-1 pattern and the two\u2019s complement of 0 is the all-0 pattern, so applying\nnegl to the word containing CF we have all-1s or all-0s. Then taking bitwise and of the result and\nesp delta gives a word containing esp delta or 0. This process is detailed in Figure 13. (The\ninstruction sequences we use have some side effects that must be worked around, but the process\nitself is straightforward.)\nNow, we have the desired perturbation, and it is simple to apply it to the stack pointer by\nmeans of the sequence\n"],"Page":10,"Number":3,"Type":"Figure","CaptionBB":[273,388,574,403],"Height":1100,"Width":850,"DPI":100,"ImageBB":[157,99,675,370]}