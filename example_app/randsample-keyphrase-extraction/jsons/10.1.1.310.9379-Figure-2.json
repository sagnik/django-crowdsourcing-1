{"Caption":"Figure 2: Execution Lease Architecture: Lease logic (dashed) bounds tainted programs in both time and space, and prevents the entire system state from becoming tainted. PC is restored to an untainted restorePC value when an untainted timer expires. Lease logic is also used to bound the memory regions the tainted code can access. ","ImageText":[{"Text":"timer","TextBB":[580.969,57.7518,600.317,66.1275],"Rotation":0},{"Text":"expired?","TextBB":[602.202,57.7518,633.891,66.1275],"Rotation":0},{"Text":"Untainted","TextBB":[491.667,65.5852,529.028,73.9609],"Rotation":0},{"Text":"1","TextBB":[575.778,78.4101,578.94,84.2164],"Rotation":0},{"Text":"PC","TextBB":[514.903,99.106,524.808,107.482],"Rotation":0},{"Text":"restore","TextBB":[594.725,75.6963,620.795,84.072],"Rotation":0},{"Text":"PC","TextBB":[622.742,75.6963,632.629,84.072],"Rotation":0},{"Text":"0","TextBB":[637.193,87.3503,640.348,93.144],"Rotation":0},{"Text":"+1","TextBB":[659.722,86.7411,667.116,93.0386],"Rotation":0},{"Text":"1","TextBB":[637.636,113.945,640.791,119.738],"Rotation":0},{"Text":"jump","TextBB":[658.987,112.223,673.722,118.521],"Rotation":0},{"Text":"target","TextBB":[674.972,112.223,691.872,118.521],"Rotation":0},{"Text":"0","TextBB":[575.778,101.271,578.933,107.065],"Rotation":0},{"Text":"is","TextBB":[639.286,141.542,643.498,147.839],"Rotation":0},{"Text":"jump?","TextBB":[644.855,141.542,662.317,147.839],"Rotation":0},{"Text":"Instr","TextBB":[504.002,144.909,518.519,152.277],"Rotation":0},{"Text":"Mem","TextBB":[521.186,144.909,537.886,152.277],"Rotation":0},{"Text":"PRegs","TextBB":[592.051,160.666,607.578,166.472],"Rotation":0},{"Text":"Reg","TextBB":[595.126,183.047,605.809,189.344],"Rotation":0},{"Text":"File","TextBB":[595.861,191.072,605.587,197.382],"Rotation":0},{"Text":"Data","TextBB":[676.392,192.723,691.722,200.091],"Rotation":0},{"Text":"Mem","TextBB":[694.906,192.723,711.605,200.091],"Rotation":0},{"Text":">","TextBB":[632.381,200.414,637.68,208.79],"Rotation":0},{"Text":"start","TextBB":[639.565,200.414,656.209,208.79],"Rotation":0},{"Text":"<","TextBB":[631.511,211.113,636.818,219.501],"Rotation":0},{"Text":"end","TextBB":[638.706,211.113,653.132,219.501],"Rotation":0},{"Text":"through","TextBB":[522.742,207.699,545.304,213.997],"Rotation":0},{"Text":"decode","TextBB":[546.555,207.699,567.513,213.997],"Rotation":0},{"Text":"Memory","TextBB":[609.661,236.837,640.674,245.212],"Rotation":0},{"Text":"Address","TextBB":[642.124,236.837,672.034,245.212],"Rotation":0},{"Text":"Bounds","TextBB":[629.587,247.533,657.666,255.909],"Rotation":0}],"Mention":["(which may or may not be tainted and where that taint\nmight either indicate secret or untrusted code) for a fixed\namount of time. Once the timer expires, control is automat-\nically restored back to a return PC value that was provided\nby the leaser when it invoked the lease. Figure 2 shows the\nLease architecture, and a scenario where untainted code\nleases the CPU to some tainted code. The timer value it-\nself and the restore PC are untainted, and when the timer\nexpires, a MUX is used to reset the PC to the restore PC.\nCorrespondingly, the GLIFT-logic observes that the MUX\noutput is dependent solely on untainted values (i.e the old\ntainted PC has no effect), and marks the PC as untainted.\nOf course nothing is ever this simple, and here the complex-\nity lies in the fact that we need to support multiple nested\nleases to support multi-level procedure calls.\nThe need for multiple nested leases naturally suggests\nmaintaining a stack of lease records that stores the time\nthe lease is active for and the PC value that the control\nmust return to when the lease expires. We have to imple-\nment a stack that stores these attributes, but where the\ninformation flow containment is inherent in its gate-level\nimplementation.\nWith each lease entry in the stack, its leaser\u2019s location\non the stack is also recorded as part of the lease entry\n(restoreSP in Figure 3). The restoreSP thus carries the\ntaint of the leaser, and this allows the Lease-CPU to pop\nleases by setting the cur lease register to its restoreSP\nvalue without having to compute the next cur lease value\n","We can use the gate-level timing and memory bound\nguarantees that leases offer to execute general purpose code,\nspecifically conditional jumps and indirect memory accesses,\nwithin a lease. For the leasee to be able to use general-\npurpose instructions, the leaser must set the Mode bit for\nthe lease, indicating a general-purpose lease. The mode\nin which the current lease is executing (GLIFT or General\nPurpose) forms part of the current context (as shown in\nFigure 2). The leaser\u2019s mode is also stored along with\neach entry in the PC stack so that the current mode regis-\nter can be restored to a trusted leaser\u2019s mode when a lease\nexpires. An interesting feature of our architecture is that\nonce a lease is set in general purpose mode, no further leases\ncan be set until the lease expires. Leases can only be set in\nGLIFT mode to ensure that the fixed size lease stack cannot\nbe used to leak information covertly, while within a general\npurpose lease, conventional call-and-return semantics can\nbe used to implement functions.\nConditional jumps help performance because they can\nallow the lease time to be limited to the maximum of the\ntwo conditional paths at an if âˆ’ else branch instead of ex-\necuting both sides of the branch. Similarly, indirect mem-\nory accesses allow programs to index into arrays arbitrarily\nwithout having to iterate over the entire array and predicat-\ning out the desired index. In the next section, we present\nthe Lease ISA and how it can be used to implement a high\nlevel language.\n","The original GLIFT architecture uses predication to pre-\nvent tainted data from ever affecting the PC, while a spe-\ncial countjump instruction allowed a fixed number of un-\nconditional jumps to support fixed-length loops, and spe-\ncial load-looprel and store-looprel instructions allowed\nprograms to access a fixed range of memory addresses in the\nloop (by using an immediate value for the base address).\nIn contrast, our Execution Lease ISA allows the caller\nof the lease to set explicit bounds on the range of mem-\nory addresses that the callee is allowed to access (using\nsetmembound-hi or setmembound-lo), and the time the callee\nwill execute for (using settimer). The setbounds instruc-\ntions set the address bounds for a given time duration and\nalong a given power-of-2 aligned boundary, while the set-\ntimer instruction sets a timer, the general-purpose mode,\nand automatically stores a PC to be restored when the lease\nexpires.\nFunction calls in the new assembly: We have chosen\nto implicitly record the third instruction after settimer (i.e.\nPC + 3) as the restore-PC, allowing for one instruction in\nthe middle for an unconditional jump to the callee and an-\nother instruction that spins in an infinite loop to wait out\nany remaining time on the lease if the callee finishes early.\nThe address of this infinite-loop instruction is suggested as\na return address to the callee as part of the calling con-\nvention. Note that even if the callee disregards the return\nPC and is still executing some code when the lease timer\nexpires, the PC will be yanked back to the restore PC that\nwas recorded when the lease timer was set. The return PC\nis suggested so that if a lease duration is longer than re-\nquired, the callee need not be concerned with waiting out\ntheir leases or completing the lease precisely without spilling\nover into others\u2019 code. If the time is insufficient, leases will\nstill ensure that the effects of an unusual code-path do not\npropagate outside the current time and space bounds.\nA function call looks like the snippet of assembly code in\nFigure 6 (that calls an I2C bus initialization function).\nAccelerated array accesses: The setbounds and set-\ntimer instructions are also used to enable indirect memory\naccesses (used for accessing array elements). Since the\nGLIFT ISA allowed only direct memory addressing, index-\ning into an array required using a loop that iterated over\nthe entire array. The chosen address was accessed by using\na predicated load (or store) that is set to True at the desired\nindex.\nFor example, consider a code snippet of the SubBytes\nfunction for an implementation of the AES [7] encryption\nalgorithm in the original ISA (Figure 7). The function sub-\nstitutes the value in the state matrix with values in the\n"],"Page":5,"Number":2,"Type":"Figure","CaptionBB":[440,258,770,333],"Height":1100,"Width":850,"DPI":100,"ImageBB":[490,55,722,256]}