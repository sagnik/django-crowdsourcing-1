{"Caption":"Figure 11: The effect of deletion on the provenance store. The notation (ac) indicates provenance table size when only add and copy operations are performed while (acd) includes deletes. ","ImageText":[{"Text":"Effects","TextBB":[192.308,416.428,223.564,425.1],"Rotation":0},{"Text":"of","TextBB":[226.17,416.428,235.02,425.1],"Rotation":0},{"Text":"Deletion","TextBB":[237.626,416.428,274.611,425.1],"Rotation":0},{"Text":"del-random","TextBB":[339.222,418.897,386.632,427.568],"Rotation":0},{"Text":"30000","TextBB":[99.7158,428.162,123.365,436.031],"Rotation":0},{"Text":"del-add","TextBB":[339.222,433.094,370.488,441.766],"Rotation":0},{"Text":"del-mix","TextBB":[339.222,447.292,369.428,455.964],"Rotation":0},{"Text":"Rows","TextBB":[90.7693,473.502,99.4412,499.085],"Rotation":3},{"Text":"25000","TextBB":[99.7158,447.915,123.365,455.784],"Rotation":0},{"Text":"del-copy","TextBB":[339.222,461.49,374.65,470.161],"Rotation":0},{"Text":"20000","TextBB":[99.7158,467.051,123.365,474.92],"Rotation":0},{"Text":"del-real","TextBB":[339.222,475.687,370.478,484.359],"Rotation":0},{"Text":"15000","TextBB":[99.7158,486.187,123.365,494.056],"Rotation":0},{"Text":"10000","TextBB":[99.7158,504.088,123.365,511.957],"Rotation":0},{"Text":"5000","TextBB":[105.271,523.224,124.191,531.093],"Rotation":0},{"Text":"0","TextBB":[120.703,542.977,125.433,550.846],"Rotation":0},{"Text":"N","TextBB":[134.901,552.853,141.043,560.722],"Rotation":0},{"Text":"(ac)","TextBB":[143.408,552.853,158.057,560.722],"Rotation":0},{"Text":"N","TextBB":[165.148,552.853,171.29,560.722],"Rotation":0},{"Text":"(acd)","TextBB":[173.655,552.853,193.034,560.722],"Rotation":0},{"Text":"H","TextBB":[200.95,552.853,207.092,560.722],"Rotation":0},{"Text":"(ac)","TextBB":[209.457,552.853,224.106,560.722],"Rotation":0},{"Text":"H","TextBB":[231.197,552.853,237.339,560.722],"Rotation":0},{"Text":"(acd)","TextBB":[239.704,552.853,259.083,560.722],"Rotation":0},{"Text":"T","TextBB":[265.765,552.853,270.963,560.722],"Rotation":0},{"Text":"(ac)","TextBB":[273.328,552.853,287.977,560.722],"Rotation":0},{"Text":"T","TextBB":[296.012,552.853,301.21,560.722],"Rotation":0},{"Text":"(acd)","TextBB":[303.575,552.853,322.954,560.722],"Rotation":0},{"Text":"Method","TextBB":[228.11,565.811,261.438,574.483],"Rotation":0},{"Text":"HT","TextBB":[336.753,552.236,348.093,560.105],"Rotation":0},{"Text":"(ac)","TextBB":[334.901,562.113,349.55,569.981],"Rotation":0},{"Text":"HT","TextBB":[370.086,552.853,381.426,560.722],"Rotation":0},{"Text":"(acd)","TextBB":[365.765,562.73,385.144,570.599],"Rotation":0}],"Mention":["space running Windows XP. The target database was a 27.3MB\ncopy of MiMI stored in Timber, and the source database was 6MB\nof data fromOrganelleDB stored inMySQL. The provenance infor-\nmation was stored separately in MySQL. We used Timber version\n1.1 and MySQL version 4.1.12a-nt via TCP\/IP. CPDB was imple-\nmented as a Java application that communicates with MySQL via\nJDBC and Timber using SOAP.\nWe performed five sets of experiments to measure the relative\nperformance of the naı¨ve (N), transactional (T), hierarchical (H),\nand hierarchical-transactional (HT) provenance storage methods.\nTable 1 summarizes the experiments we report, including a descrip-\ntion of the fixed and varying parameters, and listing the figures\ncontaining experimental results. We used six patterns of update\noperations, summarized in Table 2. The first five are random se-\nquences of adds, deletes, and copies in various proportions. The\ncopies were all of subtrees of size four (a parent with three chil-\ndren) from OrganelleDB to MiMI. The real update consisted of a\nregular pattern of copies, deletes, and inserts simulating the effect\nof a bulk update on MiMI that could be performed via a standard\nXQuery statement using XPath. It repeatedly copies a subtree into\nthe target, then inserts three elements under the subtree root and\ndeletes three existing subtree elements. We also used variations of\nthe mix dataset that exhibited different deletion patterns, shown in\nTable 3.\nIn the first set of experiments we ran 3500-step updates on each\nof the first five update patterns using each storage method. For the\ntransactional approaches, commits were performed after every five\nupdates. In each case, we measured the amount of time needed\nfor provenance manipulation, interaction with the target database,\nand interaction with the provenance database. We also measured\nthe total size of the provenance store and target database (both in\nnumber of rows and in real storage terms) at the end of the transac-\ntion. Efficiency considerations precluded measuring the size of the\nprovenance store or target database after each operation.\nIn the second experiment, we ran 14,000-step versions of the real\nand mix updates using all four provenance methods, with the same\nexperimental methodology as for the 3500-step updates. These ex-\nperiments were intended to determine how our techniques scale as\nlarger numbers of realistic user actions are performed, so we did\nnot run the less realistic add, delete, or copy update patterns of this\nlength.\nFigure 7 shows the total provenance storage in rows needed for\neach method and each run for the 3500-step updates. The real stor-\nage sizes in bytes display the same trends (each row requires be-\ntween 100 and 200 bytes), so we omit this data. Figure 8 shows\nthe total provenance storage in rows needed for each of the 14,000-\nstep runs. Numbers at the top of each bar show the physical sizes\nof the tables. Figure 9 shows the average time for target database\ninteraction, and average time per add, delete, copy, or commit op-\neration for the 14,000-mix run. These results accurately reflect ob-\nserved provenance processing times in all the other experiments, so\nwe omit this data. In order to determine how expensive provenance\ntracking is per add, delete, or copy operation, we also calculated the\naverage time for dataset manipulation by operation type; Figure 10\nshows the overhead of provenance tracking for each operation as a\npercentage of base dataset manipulation time.\nIn the third experiment, we measured the effects of deletes on\nprovenance storage. We performed five different versions of the\n14,000-mix update with varying deletion patterns. These deletion\npatterns may not be representative of common user behavior, but\ndemonstrate the storage performance of the various methods under\ndifferent conditions. Figure 11 shows the results of this experiment.\nWe plot two columns per provenance method, one (labeled \u201Cac\u201D)\n","processing time and average commit times are shown as well. Note\nthat the time for copying in transactional provenance is not zero; it\nis just close to zero because copies do not involve interaction with\nthe provenance store in transactional provenance. Figure 10 de-\npicts the average overhead of provenance processing per individual\nadd, delete, or copy operation. For naı¨ve storage, the add, delete\nand copy operations require less than 30% of the processing time\nneeded for interaction with the target database. Although hierarchi-\ncal provenance is much faster for copies, it requires more time to\nprocess inserts. (Deletes are unaffected because hierarchical prove-\nnance treats deletes exactly as naı¨ve provenance does.) More time\nis needed because we must first query the provenance database to\ndetermine whether to add the provenance record. Transactional\nprovenance, on the other hand, is much more responsive. Inserts\nand copies run essentially instantaneously, because no interaction\nwith the target database or provenance store is needed. Moreover,\ncommits require about 25% of the average time for database inter-\naction, but only occur once every five steps. The savings seem to be\ndue to the reduced number of round-trips to the provenance data-\nbase. For hierarchical-transactional storage, more time is needed\nfor copies and inserts, but all the basic operations take at most 6%\nof the total time. Commits take the same amount of time on average\nas for hierarchical provenance.\nThe effects of deletion are shown in Figure 11. For naı¨ve and\nhierarchical provenance, deletion simply adds provenance records.\nFor transactional provenance, some deletion patterns result in fewer\noverall records being stored, because some data is inserted and\ndeleted in the same transaction. However, hierarchical-transactional\nprovenance displays the most stable behavior, and stores the fewest\nrecords among the approaches for each update pattern.\nThe effect of transaction length on processing time is shown\nin Figure 12. Processing time per basic operation does not vary\nmuch with transaction size, while the amount of time needed to\nprocess a commit grows approximately linearly with transaction\nlength. The average overall time per operation remains about the\nsame. These results reflect the expected behavior, and illustrate\nthat our approach works at interactive speeds (at most one or two\nseconds) for transactions of up to 100 operations. Committing the\ncorresponding changes to the target database is likely to take as\nlong or longer. More sophisticated techniques that minimize net-\nwork round trips during commits could further reduce the overall\nprocessing time.\nFinally, Figure 13 displays the time needed to query the vari-\nous forms of provenance using the getSrc, getMod, and getHist\nqueries. In general, it is expected that getHist will outperform\ngetSrc, and both will do better than getMod based on the prove-\n"],"Page":9,"Number":11,"Type":"Figure","CaptionBB":[73,607,407,649],"Height":1100,"Width":850,"DPI":100,"ImageBB":[88,412,395,575]}