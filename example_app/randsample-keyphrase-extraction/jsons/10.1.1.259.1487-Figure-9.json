{"Caption":"Figure 9: When the \u201CStale Method\u201D exception is received by the client dynamic class, the JPie debugger detects the exception and prompts the user. The goal of SDE and CDE is to make the error apparent to the client programmer. ","ImageText":[],"Mention":[" To overcome the inconsistency shown in Figure 7, we \ndeveloped the mechanism shown in Figure 8 that is \nimplemented jointly by CDE and SDE.   \n In CDE, when a \u201CStale Method\u201D exception is received \nby the client backend, the client view of the server \ninterface is updated to the currently published one. The \nexception is then sent to the dynamic class that made the \noriginal RMI call. The JPie Debugger [12] detects the \nexception and displays it to the user as shown in Figure 9. \nWhen the user inspects the error, the server interface \nchange is clearly visible. At this point, the user may make \nthe necessary changes and resume normal execution. \n After the server sends a \u201CStale Method\u201D exception \nback to the client, there is a possibility that the server \nmethod signature is subsequently changed (during forced \npublication) to match the original call. In this case, we do \nnot want the user to see the exception since the method call \nis actually consistent with the server interface. Therefore, \nwhen CDE receives a \u201CStale Method\u201D exception from the \nserver, it first compares the relevant method signature in \nthe latest server interface description with the signature of \nthe RMI call that trigged the update. If the signatures are \nidentical, the call is silently re-invoked. Otherwise, the \nexception is propagated to the JPie debugger.  \n"],"Page":9,"Number":9,"Type":"Figure","CaptionBB":[79,370,411,451],"Height":1100,"Width":850,"DPI":100,"ImageBB":[78,102,414,360]}