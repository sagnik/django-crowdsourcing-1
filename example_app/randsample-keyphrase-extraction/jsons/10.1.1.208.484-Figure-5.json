{"Caption":"Figure 5: Pairs of requests executed per second at the cloud as depending on the number of workers. ","ImageText":[{"Text":"20","TextBB":[126.933,121.739,136.663,130.052],"Rotation":0},{"Text":"15","TextBB":[126.933,143.439,136.663,151.752],"Rotation":0},{"Text":"*2","TextBB":[118.299,181.363,126.612,189.632],"Rotation":3},{"Text":"Requests\/sec","TextBB":[118.299,125.923,126.612,178.93],"Rotation":3},{"Text":"25","TextBB":[126.933,100.039,136.663,108.352],"Rotation":0},{"Text":"10","TextBB":[126.933,165.11,136.663,173.423],"Rotation":0},{"Text":"5","TextBB":[131.798,186.81,136.663,195.123],"Rotation":0},{"Text":"Read","TextBB":[242.246,192.877,263.159,201.189],"Rotation":0},{"Text":"Write","TextBB":[242.745,202.064,263.159,210.377],"Rotation":0},{"Text":"0","TextBB":[131.798,208.51,136.663,216.823],"Rotation":0},{"Text":"0","TextBB":[140.696,217.26,145.561,225.573],"Rotation":0},{"Text":"5","TextBB":[173.771,217.26,178.636,225.573],"Rotation":0},{"Text":"10","TextBB":[204.414,217.26,214.144,225.573],"Rotation":0},{"Text":"15","TextBB":[237.46,217.26,247.19,225.573],"Rotation":0},{"Text":"No.","TextBB":[195.399,230.385,209.014,238.698],"Rotation":0},{"Text":"of","TextBB":[211.446,230.385,218.744,238.698],"Rotation":0},{"Text":"Workers","TextBB":[221.176,230.385,253.744,238.698],"Rotation":0},{"Text":"20","TextBB":[270.535,217.26,280.265,225.573],"Rotation":0},{"Text":"25","TextBB":[303.61,217.26,313.34,225.573],"Rotation":0}],"Mention":["cloud (a request is sent only after the previous request\nfinished); this experiment is repeated many times. We\nmeasure how many pairs of requests are satisfied per sec-\nond as we increase the number of worker roles. Figure 5\nshows our results. We can see that each pair of requests is\nsatisfied in about 1s which makes sense given the latency\nresults presented above. We can see that the scaling is\nindeed approximately linear. This makes sense because\nwe designed our security protocols to allow all requests\nto proceed in parallel if they touch different blocks.\nMoreover, for scalability, our access control scheme\nshould be able to support efficiently many members and\nblocks. Our scheme has the benefit that revocation and\naddition do not depend on the number of blocks in a fam-\nily. It only depends on the square root of the number of\nmembers with access to the block family. As we can see\nin Figure 7, the square root factor is almost irrelevant; the\nreason is that the constants multiplying the square root\nare much smaller than the constant latency of read and\nwrite. We can see that for large enterprises with 100,000\nemployees, group addition and revocation remain afford-\nable even if every single employee is present on an access\ncontrol list.\nA block family is created when a block\u2019s ACL is\nchanged to an ACL that no other block has. The owner\nmust put a new family key block on the cloud. If the\nmembership change from the previous ACL (if one ex-\nisted) to the current one is not large, the owner can just\ncopy the family key block for the previous ACL and per-\nform the appropriate revocations and additions. Other-\nwise, the owner should choose new keys, compute broad-\ncast encryptions to the new members, and put the result-\ning data on the cloud. For an ACL of 1000 new mem-\nbers, these operations sum up to â‰ˆ 20s. Any blocks\nadded to the block family will not require key block fam-\nily changes. The block just needs to be encrypted with\nthe proper key.\n"],"Page":12,"Number":5,"Type":"Figure","CaptionBB":[116,239,313,279],"Height":1100,"Width":850,"DPI":100,"ImageBB":[116,98,315,239]}